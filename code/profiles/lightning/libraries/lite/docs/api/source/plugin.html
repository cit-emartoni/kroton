<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
Copyright 2015 LoopIndex, This file is part of the Track Changes plugin for CKEditor.

The track changes plugin is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License, version 2, as published by the Free Software Foundation.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU Lesser General Public License along with this program as the file lgpl.txt. If not, see http://www.gnu.org/licenses/lgpl.html.

Written by (David *)Frenkiel - https://github.com/imdfl
*/
(function(CKEDITOR, global) {

	&quot;use strict&quot;;

<span id='LITE'>	/**
</span>	 * @class LITE
	 * @singleton
	 * The LITE namespace
	 */
	var LITE = {
<span id='LITE-Events'>			/**
</span>			 * @class LITE.Events
			 */
		Events : {
<span id='LITE-Events-event-INIT'>			/**
</span>			 * @member LITE.Events
			 * @event INIT
			 * string value: &quot;lite:init&quot;
			 * @param {LITE.LITEPlugin} lite an instance of a lite object associated with a ckeditor instance
			 */
			INIT : &quot;lite:init&quot;,
<span id='LITE-Events-event-ACCEPT'>			/**
</span>			 * @member LITE.Events
			 * @event ACCEPT
			 * string value: &quot;lite:accept&quot;
			 * @param {LITE.LITEPlugin} lite an instance of a lite object associated with a ckeditor instance
			 * @param {Object} options filtering options
			 */
			ACCEPT : &quot;lite:accept&quot;,
<span id='LITE-Events-event-REJECT'>			/**
</span>			 * @member LITE.Events
			 * @event REJECT
			 * string value: &quot;lite:reject&quot;
			 * @param {LITE.LITEPlugin} lite an instance of a lite object associated with a ckeditor instance
			 * @param {Object} options filtering options
			 */

			REJECT : &quot;lite:reject&quot;,
<span id='LITE-Events-event-SHOW_HIDE'>			/**
</span>			 * @member LITE.Events
			 * @event SHOW_HIDE
			 * string value: &quot;lite:showHide&quot;
			 * @param {LITE.LITEPlugin} lite an instance of a lite object associated with a ckeditor instance
			 * @param {Boolean} show indicates the new change tracking show status
			 */
			SHOW_HIDE : &quot;lite:showHide&quot;,
<span id='LITE-Events-event-TRACKING'>			/**
</span>			 * @member LITE.Events
			 * @event TRACKING
			 * string value: &quot;lite:tracking&quot;
			 * @param {LITE.LITEPlugin} lite an instance of a lite object associated with a ckeditor instance
			 * @param {Boolean} tracking indicates the new tracking status
			 */
			TRACKING : &quot;lite:tracking&quot;,
			
<span id='LITE-Events-event-CHANGE'>			/**
</span>			 * @member LITE.Events
			 * @event CHANGE
			 * string value: &quot;lite:change&quot;
			 * @param {LITE.LITEPlugin} lite an instance of a lite object associated with a ckeditor instance
			 */
			CHANGE : &quot;lite:change&quot;,

<span id='LITE-Events-event-HOVER_IN'>			/**
</span>			 * @member LITE.Events
			 * @event HOVER_IN
			 * string value: &quot;lite:hover-in&quot;
			 * @param {LITE.LITEPlugin} lite an instance of a lite object associated with a ckeditor instance
			 * @param {Object} node The DOM node hovered
			 * @param {String} changeId The relevant change id
			 */
			HOVER_IN: &quot;lite:hover-in&quot;,

<span id='LITE-Events-event-HOVER_OUT'>			/**
</span>			 * @member LITE.Events
			 * @event HOVER_OUT
			 * string value: &quot;lite:hover-out&quot;
			 * @param {LITE.LITEPlugin} lite an instance of a lite object associated with a ckeditor instance
			 * @param {Object} node The DOM node hovered
			 * @param {String} changeId The relevant change id
			 */
			HOVER_OUT: &quot;lite:hover-out&quot;
		},
		
		Commands : {
			TOGGLE_TRACKING : &quot;lite-toggletracking&quot;,
			TOGGLE_SHOW : &quot;lite-toggleshow&quot;,
			ACCEPT_ALL : &quot;lite-acceptall&quot;,
			REJECT_ALL : &quot;lite-rejectall&quot;,
			ACCEPT_ONE : &quot;lite-acceptone&quot;,
			REJECT_ONE : &quot;lite-rejectone&quot;,
			TOGGLE_TOOLTIPS: &quot;lite-toggletooltips&quot;
		}
	},
	
	tooltipDefaults = {
		show: true,
		path: &quot;js/opentip-adapter.js&quot;,
		classPath: &quot;OpentipAdapter&quot;,
		cssPath: &quot;css/opentip.css&quot;,
		delay: 500
	},
	
	defaultTooltipTemplate = null,

	LITEConstants = {
		deleteTag: 'del',
		insertTag: 'ins',
		deleteClass: 'ice-del',
		insertClass: 'ice-ins',
		attributes: {
			changeId: &quot;data-cid&quot;,
			userId: &quot;data-userid&quot;,
			userName: &quot;data-username&quot;,
			sessionId: &quot;data-session-id&quot;,
			changeData: &quot;data-changedata&quot;,
			time: &quot;data-time&quot;,
			lastTime: &quot;data-last-change-time&quot;
		},
		stylePrefix: 'ice-cts',
		preserveOnPaste: 'p',
		css: 'css/lite.css'
	},
	
	defaultTooltipTemplate = &quot;%a by %u %t&quot;,
	
	ice = null,
	
	_emptyRegex = /^[\s\r\n]*$/, // for getting the clean text
		_cleanRE = [
		            {regex: /[\s]*title=\&quot;[^\&quot;]+\&quot;/g, replace: &quot;&quot; },
		            {regex: /[\s]*data-selected=\&quot;[^\&quot;]+\&quot;/g, replace:&quot;&quot;}
		],
	
	_pluginMap = [],
	
	cutKeystrokes = [CKEDITOR.CTRL + 88,  // CTRL+X
			CKEDITOR.CTRL + 120,
			CKEDITOR.SHIFT + 46],
	isOldCKEDITOR = false;

	
	function cleanNode(node) {
		var ret, name, parent,
			i, len, child;
		if (node.nodeType === ice.dom.ELEMENT_NODE) {
			var children = node.childNodes;
			for (i = 0; i &lt; children.length; ++i) {
				child = children[i];
				cleanNode(child);
				name = child.nodeName.toLowerCase();
				if (name === LITEConstants.insertTag || name === LITEConstants.deleteTag) {
					while (child.firstChild) {
						node.insertBefore(child.firstChild, child);
					}
					node.removeChild(child);
				}
			}
		}
		name = node.nodeName.toLowerCase();
		if (name === 'ins' || name === 'del') {
			ret = jQuery.makeArray(node.childNodes);
		}
		else {
			ret = [node];
		}
		return ret;
	}
	
	function cleanClipboard(nodes) {
		if (! nodes ||! nodes.length) {
			return [];
		}
		var ret = [];
		nodes.forEach(function(node) {
			ret = ret.concat(cleanNode(node));
		});
		
		return ret;
	}
	
	function isCutKeystroke(code) {
		return cutKeystrokes.indexOf(code) &gt;= 0;
	}
	
	function nodeToDOMNode(node) {
		if (node &amp;&amp; node.$ &amp;&amp; (typeof node.getDocument === &quot;function&quot;)) {
			return node.$;
		}
		return node;
	}
	
	function _findPluginIndex(editor) {
		for (var i = _pluginMap.length; i--;) {
			var rec = _pluginMap[i];
			if (rec.editor === editor) {
				return i;
			}
		}
		return -1;
	}
	
	function _findPluginRec (editor) {
		var ind = _findPluginIndex(editor);
		return ind &gt;= 0 ? _pluginMap[ind] : null;
	}
	
	function _findPlugin(editor) {
		var rec = _findPluginRec(editor);
		return rec &amp;&amp; rec.plugin;
	}
	
	function addPlugin(editor, plugin) {
		_pluginMap.push({
			plugin: plugin,
			editor : editor
		});
	}

	function padString(s, length, padWith, bSuffix) {
		if (null === s || (typeof(s) === &quot;undefined&quot;)) {
			s = &quot;&quot;;
		}
		else {
			s = String(s);
		}
		padWith = String(padWith);
		var padLength = padWith.length;
		for (var i = s.length; i &lt; length; i += padLength) {
			if (bSuffix) {
				s += padWith;
			}
			else {
				s = padWith + s;
			}
		}
		return s;
	}
	
	function padNumber(s, length) {
		return padString(s, length, '0');
	}
	
	function relativeDateFormat(date, lang) {
		var now = new Date(),
			today = now.getDate(),
			month = now.getMonth(),
			year = now.getFullYear(),
			minutes, hours; 
		
		var t = typeof(date);
		if (t === &quot;string&quot; || t === &quot;number&quot;) {
			date = new Date(date);
		}
		
		var months = lang.MONTHS;
		
		if (today == date.getDate() &amp;&amp; month == date.getMonth() &amp;&amp; year == date.getFullYear()) {
			minutes = Math.floor((now.getTime() - date.getTime()) / 60000);
			if (minutes &lt; 1) {
				return lang.NOW;
			}
			else if (minutes &lt; 2) {
				return lang.MINUTE_AGO;
			}
			else if (minutes &lt; 60) {
				return (lang.MINUTES_AGO.replace(&quot;xMinutes&quot;, minutes));
			}
			else {
				hours = date.getHours();
				minutes = date.getMinutes();
				return lang.AT + &quot; &quot; + padNumber(hours, 2) + &quot;:&quot; + padNumber(minutes, 2, &quot;0&quot;);
			}
		} 
		else if (year == date.getFullYear()) {
			return lang.ON + &quot; &quot; + lang.LITE_LABELS_DATE(date.getDate(), date.getMonth());
		}
		else {
			return lang.ON + &quot; &quot; + lang.LITE_LABELS_DATE(date.getDate(), date.getMonth(), date.getFullYear());
		}
	}
	
	var initModule = function() {
		var ckv = parseFloat(CKEDITOR.version);
		isOldCKEDITOR = isNaN(ckv) || ckv &lt; 4.4;
		initModule = function(){};
	};
	
<span id='LITE-Events-method-elementMatchesSelectors'>	/**
</span>	 * returns true if the element matches one of the patterns
	 */
	function elementMatchesSelectors($el, patterns) {
		var i, len = patterns &amp;&amp; patterns.length;
		if (! $el || ! len) {
			return false;
		}
		for (i = 0; i &lt; len; ++i) {
			if ($el.is(patterns[i])) {
				return true;
			}
		}
		return false;
	}
	
<span id='LITE-AcceptRejectOptions'>	/**
</span>	 * @class LITE.AcceptRejectOptions
	 * A map of options for filtering changes before they're accepted/rejected.
	 */
	
<span id='LITE-AcceptRejectOptions-property-include'>	/**
</span>	 * @member LITE.AcceptRejectOptions
	 * @property {Array} include
	 * An array of user ids to include. Only changes made by users in the include list will be accepted/rejected
	 */
	
<span id='LITE-AcceptRejectOptions-property-exclude'>	/**
</span>	 * @member LITE.AcceptRejectOptions
	 * @property {Array} exclude
	 * An array of user ids to exclude. Changes made by users in the exclude list will be not accepted/rejected
	 */
	
<span id='LITE-AcceptRejectOptions-property-filter'>	/**
</span>	 * @member LITE.AcceptRejectOptions
	 * @property {Function} filter
	 * a filter function of the form function({userid, time, data}):boolean . Only changes for which the function
	 * returns true are accepted/rejected
	 */

<span id='LITE-configuration'>	/**
</span>	 * @class LITE.configuration
	 * The configuration object for the {@link LITE.lite} and the {@link LITE.LITEPlugin} objects
	 * This object is usually created in the CKEditor configuration file. It can also be created/modified
	 * in the callback for CKEditor's &lt;strong&gt;configLoaded&lt;/strong&gt; event
	 * &lt;p&gt;In the config file, create this object with code such as:
	 * &lt;pre&gt;
	 * CKEDITOR.editorConfig = function( config ) {
	 * // ... your own configuration
	 *		var lite = config.lite = (config.lite || {});
	 * // now assign values to properties: lite.xxx = yyy;
	 * &lt;/pre&gt;
	 * And here's an example for configuring lite in the &lt;strong&gt;configLoaded&lt;/strong&gt; event:
	 * &lt;pre&gt;
	 * 		function onConfigLoaded(e) {
	 *  		var conf = e.editor.config;
	 *  		var lt = conf.lite = (conf.lite || {});
	 *  		lt.isTracking = false; 
	 *  	}
	 *  &lt;/pre&gt;
	 */	

	
<span id='LITE-configuration-property-isTracking'>	/**
</span>	 * @member LITE.configuration
	 * @property {Boolean} isTracking
	 * Initial tracking state of the plugin. Default: &lt;code&gt;true&lt;/code&gt;
	 */
	
<span id='LITE-configuration-property-debug'>	/**
</span>	 * @member LITE.configuration
	 * @property {Object} debug
	 * set debug.log to true for LITE to print error messages in the browser console
	 */
	
<span id='LITE-configuration-property-includes'>	/**
</span>	 * @member LITE.configuration
	 * @property {Array} includes
	 * sets the javascript include files to be included in LITE instead of the default. Use only for debugging or extending the plugin
	 */

<span id='LITE-configuration-property-userStyles'>	/**
</span>	 * @member LITE.configuration
	 * @property {Object} userStyles
	 * A map of user id=&gt;user style index
	 * Normally LITE will assign a style number for each user id it encounters in the markup. If you want to maintain consistent
	 * style per users (e.g. Melixon is always colored green, Thierry in chartreuse), assign a value to this property, e.g.
	 * &lt;pre&gt; 
	 * 	lite.userStyles = {
	 * 		15: 1,
	 * 		18:2,
	 * 		21:3
	 * 	};
	 * &lt;/pre&gt;
	 */
	
<span id='LITE-configuration-property-tooltips'>	/**
</span>	 * @member LITE.configuration
	 * @property {Object} tooltips
	 * Configures the tooltips shown by LITE
	 * &lt;div&gt;&lt;strong&gt;Omit the classPath member in order to get tooltips in standard html title elements&lt;/strong&gt;&lt;/div&gt;
	 * These are the default values used by LITE:
	 * &lt;pre&gt;
	 * 	lite.tooltips = {
	 * 		show: true, // set to false to prevent tooltips
	 * 		path: &quot;js/opentip-adapter.js&quot;, // change to point to your own implementation
	 * 		classPath: &quot;OpentipAdapter&quot;, // the full name of tooltip class construtor
	 * 		cssPath: &quot;css/opentip.css&quot;, // the stylesheet file of the tooltips
	 * 		delay: 500 // the delay in milliseconds between hovering over a change node and the appearance of a tooltip
	 * 	};
	 * &lt;/pre&gt;
	 * 
	 */
	
<span id='LITE-configuration-property-jQueryPath'>	/**
</span>	 * @member LITE.configuration
	 * @property {String} jQueryPath=&quot;js/jquery.min.js&quot;
	 * the path (relative to the LITE plugin.js file) to jQuery
	 */

<span id='LITE-configuration-property-tooltipTemplate'>	/**
</span>	 * @member LITE.configuration
	 * @property {String} tooltipTemplate=&quot;%a by %u %t&quot;
	 * A format string used to create the content of tooltips shown over change spans
	 * &lt;h3&gt;formats&lt;/h3&gt;
	 * (use uppercase to apply the format to the last modification date of the change span rather than the first) 
	 * &lt;ul&gt;
	 * &lt;li&gt;&lt;strong&gt;%a&lt;/strong&gt;  The action, &quot;added&quot; or &quot;deleted&quot; (not internationalized yet)
	 * &lt;li&gt;&lt;strong&gt;%t&lt;/strong&gt;  Timestamp of the first edit action in this change span (e.g. &quot;now&quot;, &quot;3 minutes ago&quot;, &quot;August 15 1972&quot;)
	 * &lt;li&gt;&lt;strong&gt;%u&lt;/strong&gt;  the name of the user who made the change
	 * &lt;li&gt;&lt;strong&gt;%dd&lt;/strong&gt; double digit date of change, e.g. 02
	 * &lt;li&gt;&lt;strong&gt;%d&lt;/strong&gt;  date of change, e.g. 2
	 * &lt;li&gt;&lt;strong&gt;%mm&lt;/strong&gt; double digit month of change, e.g. 09
	 * &lt;li&gt;&lt;strong&gt;%m&lt;/strong&gt;  month of change, e.g. 9
	 * &lt;li&gt;&lt;strong&gt;%yy&lt;/strong&gt; double digit year of change, e.g. 11
	 * &lt;li&gt;&lt;strong&gt;%y&lt;/strong&gt;  full month of change, e.g. 2011
	 * &lt;li&gt;&lt;strong&gt;%nn&lt;/strong&gt; double digit minutes of change, e.g. 09
	 * &lt;li&gt;&lt;strong&gt;%n&lt;/strong&gt;  minutes of change, e.g. 9
	 * &lt;li&gt;&lt;strong&gt;%hh&lt;/strong&gt; double digit hour of change, e.g. 05
	 * &lt;li&gt;&lt;strong&gt;%h&lt;/strong&gt;  hour of change, e.g. 5
	 * &lt;/ul&gt;
	 */
	
<span id='LITE-configuration-property-contextMenu'>	/**
</span>	 * @member LITE.configuration
	 * @property {Boolean} contextMenu
	 * If false, don't add LITE commands to CKEditor's context menu
	 */
	
<span id='LITE-configuration-property-ignoreSelectors'>	/**
</span>	 * @member LITE.configuration
	 * @property {Array} ignoreSelectors
	 * Array of CSS selector strings. When LITE processes insertion of html (e.g. clipboard paste or some other plugin
	 * invoking CKEditor's &lt;code&gt;insertHtml()&lt;/code&gt;, it will skip nodes that match any of these selectors plus
	 * those that contain a non-empty value for the attribute &lt;code&gt;data-track-changes-ignore&lt;/code&gt;. Note that mixing ignore
	 * and unignored nodes in the same insertion is not very useful, since the insertion will be handled entirely by
	 * LITE if at least one node is not ignored.
	 */

<span id='LITE-lite'>	/**
</span>	 * @class LITE.lite
	 * The plugin object created by CKEditor. Since only one plugin is created per web page which may contain multiple instances of CKEditor, this object only handles
	 * the lifecycle of {@link LITE.LITEPlugin} the real plugin object.
	 * 
	 */
	CKEDITOR.plugins.add( 'lite',
	{
		
		icons: &quot;lite-acceptall,lite-acceptone,lite-rejectall,lite-rejectone,lite-toggleshow,lite-toggletracking&quot;,// %REMOVE_LINE_CORE%
		hidpi: true,
		lang: [&quot;en&quot;, &quot;de&quot;],

		_scriptsLoaded : null, // not false, which means we're loading
		
<span id='LITE-lite-method-init'>		/**
</span>		 * Called by CKEditor to init the plugin
		 * Creates an instance of a {@link LITE.LITEPlugin} if one is not already associated with the given editor. 
		 * @param ed an instance of CKEditor
		 */
		init: function(ed) {
			initModule();
			var rec = _findPluginRec(ed);
			if (rec) { // should not happen
				return;
			}

			var path = this.path,
				plugin = new LITEPlugin(path),
				liteConfig = CKEDITOR.tools.extend({}, ed.config.lite || {}),
				ttConfig = liteConfig.tooltips;
			
			if (undefined === ttConfig) {
				ttConfig = true;
			}
				
			if (ttConfig === true) {
				ttConfig = tooltipDefaults;
			}
			liteConfig.tooltips = ttConfig;
			
			addPlugin(ed, plugin);
			
			plugin.init(ed, liteConfig);
	
		
			ed.on(&quot;destroy&quot;, (function(editor) {
				var ind = _findPluginIndex(editor);
				if (ind &gt;= 0) {
					_pluginMap.splice(ind, 1);
				}
			}).bind(this));
			
			if (this._scriptsLoaded) {
				plugin._onScriptsLoaded();
				return;
			}
			else if (this._scriptsLoaded === false) { // still loading, initial value was null
				return;
			}
			
			this._scriptsLoaded = false;
			var	jQueryLoaded = (typeof(jQuery) === &quot;function&quot;),
				self = this,
				jQueryPath = liteConfig.jQueryPath || &quot;js/jquery.min.js&quot;,
				scripts = (liteConfig.includeType ? liteConfig[&quot;includes_&quot; + liteConfig.includeType] : liteConfig.includes) || [&quot;lite-includes.js&quot;];
			
			scripts = scripts.slice(); // create a copy not referenced by the config
			
			for (var i = 0, len = scripts.length; i &lt; len; ++i) {
				scripts[i] = path + scripts[i]; 
			}
			if (! jQueryLoaded) {
				scripts.splice(0, 0, this.path + jQueryPath);
			}
			if (ttConfig.path) {
				scripts.push(this.path + ttConfig.path);
			}
			
			var load1 = function() {
				if (scripts.length &lt; 1) {
					self._scriptsLoaded = true;
					ice = global.ice;
					if (! jQueryLoaded) {
						jQuery.noConflict();
					}
					jQuery.each(_pluginMap, (function(i, rec) {
						rec.plugin._onScriptsLoaded();
					}));
				}
				else {
					var script = scripts.shift();
					CKEDITOR.scriptLoader.load(script, function() {load1();}, self);
				}
			};
			
			load1(scripts);		
		},
		
<span id='LITE-lite-method-findPlugin'>		/**
</span>		 * returns the plugin instance associated with an editor
		 * @param {Object} editor A CKEditor instance. Each ckeditor instance has its own instance of a LITE plugin 
		 * @returns {LITE.LITEPlugin} A LITE plugin instance
		 */
		findPlugin : function(editor) {
			return _findPlugin(editor);
		},
		
<span id='LITE-lite-method-startNewSession'>		/**
</span>		 * starts a new session in the plugin instance associated with an editor
		 * @param {Object} editor a CKEditor instance, in which the associated LITE plugin will start the session
		 */
		startNewSession: function(editor) {
			var plugin = _findPlugin(editor);
			if (plugin) {
				plugin.startNewSession();
			}
			else {
				_logError(&quot;startNewSession: plugin not found&quot;);
			}
		}
		
	});
	
<span id='LITE-LITEPlugin'>	/**
</span>	 * @class LITE.LITEPlugin
	 * The LITEPlugin is created per instance of a CKEditor. This object handles all the events and commands associated with change tracking in a specific editor.
	 */
	var LITEPlugin = function(path) {
		this.path = path;
	};

	LITEPlugin.prototype = {
<span id='LITE-LITEPlugin-method-init'>		/**
</span>		 * Called by CKEditor to init the plugin
		 * @param ed an instance of CKEditor
		 * @param {LITE.configuration} config a LITE configuration object, not null, ready to be used as a local copy
		 */
		init: function(ed, config) {
			var lang = ed.lang.lite;
			this._editor = ed;
			this._domLoaded =  false;
			this._editor =  null;
			this._tracker =  null;
			this._isVisible =  true; // changes are visible
			this._liteCommandNames =  [];
			this._canAcceptReject =  true; // enable state for accept reject overriding editor readonly
			this._removeBindings = [];
			
			if (! defaultTooltipTemplate) {
				defaultTooltipTemplate = &quot;%a &quot; + lang.lite.BY + &quot; %u %t&quot;;
			}

			ed.ui.addToolbarGroup('lite');
			this._setPluginFeatures(ed, LITEConstants);
			this._changeTimeout = null;
			this._notifyChange = this._notifyChange.bind(this);
			this._notifyTextChange = this._notifyTextChange.bind(this);

			this._config = config;
			
			var allow = config.acceptRejectInReadOnly === true;
			var commandsMap = 	[	
				{
					command : LITE.Commands.TOGGLE_TRACKING,
					exec : this._onToggleTracking, 
					title: lang.TOGGLE_TRACKING,
//					icon: &quot;track_changes_on_off.png&quot;,
					trackingOnly : false
				},
				{
					command: LITE.Commands.TOGGLE_SHOW, 
					exec: this._onToggleShow, 
					title: lang.TOGGLE_SHOW,
//					icon: &quot;show_hide.png&quot;,
					readOnly : true
				},
				{
					command:LITE.Commands.ACCEPT_ALL, 
					exec:this._onAcceptAll, 
					title: lang.ACCEPT_ALL,
//					icon:&quot;accept_all.png&quot;,
					readOnly : allow
				},
				{
					command:LITE.Commands.REJECT_ALL,
					exec: this._onRejectAll,
					title: lang.REJECT_ALL, 
//					icon:&quot;reject_all.png&quot;,
					readOnly : allow
				},
				{
					command:LITE.Commands.ACCEPT_ONE,
					exec:this._onAcceptOne,
					title: lang.ACCEPT_ONE,
//					icon:&quot;accept_one.png&quot;,
					readOnly : allow
				},
				{
					command:LITE.Commands.REJECT_ONE,
					exec:this._onRejectOne,
					title: lang.REJECT_ONE,
//					icon:&quot;reject_one.png&quot;,
					readOnly : allow
				},
				{
					command:LITE.Commands.TOGGLE_TOOLTIPS,
					exec:this._onToggleTooltips,
					readOnly : true
				}
			];
		
			this._isTracking = config.isTracking !== false; // user preference for tracking state
			this._trackingState = null; // reflects the real tracking state, not just the user pref
			this._eventsBounds = false;
		
			ed.on(&quot;contentDom&quot;, (function(dom) {
				this._onDomLoaded(dom);
			}).bind(this));
			ed.on(&quot;dataReady&quot;, (function(evt) {
				this._onAfterSetData(evt);
			}).bind(this));
			var path = this.path;
		
			var commands = config.commands || [LITE.Commands.TOGGLE_TRACKING, LITE.Commands.TOGGLE_SHOW, LITE.Commands.ACCEPT_ALL, LITE.Commands.REJECT_ALL, LITE.Commands.ACCEPT_ONE, LITE.Commands.REJECT_ONE];
		
			var self = this;
			
			function add1(rec) {
				ed.addCommand(rec.command, {
					exec : rec.exec.bind(self),
					readOnly: rec.readOnly || false
				});
		
				if (rec.title &amp;&amp; commands.indexOf(rec.command) &gt;= 0) { // configuration doens't include this command
					var name = self._commandNameToUIName(rec.command);
					ed.ui.addButton(name, {
						label : rec.title,
						command : rec.command,
//						icon : path + &quot;icons/&quot; + rec.icon,
						toolbar: &quot;lite&quot;
					}); 
					if (rec.trackingOnly !== false) {
						self._liteCommandNames.push(rec.command);
					}
				}
			}
			
			
			for (var i = 0, len = commandsMap.length; i &lt; len; ++i) {
				add1(commandsMap[i]);
			}
			
			if (config.contextMenu !== false) {
				if ( ed.addMenuItems ) {
					ed.addMenuGroup ( 'lite', 50);
					var params = {};
					if (commands.indexOf(LITE.Commands.ACCEPT_ONE) &gt;= 0) {
						params[LITE.Commands.ACCEPT_ONE] = {
							label :  lang.ACCEPT_ONE,
							command : LITE.Commands.ACCEPT_ONE,
							group : 'lite',
							order : 1
						};
					}
					if (commands.indexOf(LITE.Commands.REJECT_ONE) &gt;= 0) {
						params[LITE.Commands.REJECT_ONE] = {
							label : lang.REJECT_ONE,
							command : LITE.Commands.REJECT_ONE,
							group : 'lite',
							order : 2
						};
					}
					ed.addMenuItems(params);
				}
	
				if ( ed.contextMenu ) {
					ed.contextMenu.addListener( (function( element /*, selection */ ) {
						 if (element &amp;&amp; this._tracker &amp;&amp; this._tracker.currentChangeNode(element)) {
							 var ret = {};
							 ret[LITE.Commands.ACCEPT_ONE] = CKEDITOR.TRISTATE_OFF;
							 ret[LITE.Commands.REJECT_ONE]= CKEDITOR.TRISTATE_OFF;
							 return ret;
						 }
						 else {
							 return null;
						 }
					}).bind(this) );
				}
			}
		},
		
<span id='LITE-LITEPlugin-method-toggleTracking'>		/**
</span>		 * Change the state of change tracking for the change editor associated with this plugin.
		 * Toggles tracking visibility in accordance with the tracking state. 
		 * @param {Boolean} track if undefined - toggle the state, otherwise set the tracking state to this value, 
		 * @param {Object} options an optional object with the following fields: &lt;ul&gt;&lt;li&gt;notify: boolean, if not false, dispatch the TRACKING event&lt;/li&gt;
		 * &lt;li&gt;force: if true, don't check for pending changes and just toggle&lt;/li&gt;&lt;/ul&gt;
		 */	
		toggleTracking: function(track, options) {
			if (&quot;boolean&quot; === typeof options) {
				options = {
						notify: options
				};
			}
			options = options || {};
			
			var tracking = (undefined === track) ? ! this._isTracking : track,
				e = this._editor,
				lang = this._editor.lang.lite,
				force = options &amp;&amp; options.force;
			if (! tracking &amp;&amp; this._isTracking &amp;&amp; ! force) {
				var nChanges = this._tracker.countChanges({verify: true});
				if (nChanges) {
					return window.alert(lang.PENDING_CHANGES);
				}
			}
			this._isTracking = tracking;
			this._setCommandsState(this._liteCommandNames, tracking ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
			
			this._updateTrackingState();
			this.toggleShow(tracking, false);

			this._setCommandsState(LITE.Commands.TOGGLE_TRACKING, tracking ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);
			var ui = e.ui.get(this._commandNameToUIName(LITE.Commands.TOGGLE_TRACKING));
			if (ui) {
				this._setButtonTitle(ui, tracking ? lang.STOP_TRACKING : lang.START_TRACKING);
			}
			if (options.notify !== false) {
				e.fire(LITE.Events.TRACKING, {tracking:tracking, lite:this});
			}
		},
		
<span id='LITE-LITEPlugin-method-toggleShow'>		/**
</span>		 * Change the visibility of tracked changes for the change editor associated with this plugin
		 * @param {Boolean} [show=undefined] if show is a boolean value, set the visibility state to this value, otherwise toggle the state
		 * @param {Boolean} [bNotify=true] if not false, dispatch the TOGGLE_SHOW event
		 */	
		toggleShow : function(show, bNotify) {
			var vis = (typeof(show) === &quot;undefined&quot;) ? (! this._isVisible) : show,
				lang = this._editor.lang.lite;
			this._isVisible = vis;
			if (this._isTracking) {
				this._setCommandsState(LITE.Commands.TOGGLE_SHOW, vis ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);
			}
			this._tracker.setShowChanges(vis &amp;&amp; this._isTracking);
			
			var ui = this._editor.ui.get(this._commandNameToUIName(LITE.Commands.TOGGLE_SHOW));
			if (ui) {
				this._setButtonTitle(ui, vis ? lang.HIDE_TRACKED : lang.SHOW_TRACKED);
			}
			if (bNotify !== false) {
				this._editor.fire(LITE.Events.SHOW_HIDE, {show:vis, lite:this});
			}
		},
		
<span id='LITE-LITEPlugin-method-isVisible'>		/**
</span>		 * Are tracked changes visible?
		 * @returns {Boolean} true if tracked changes are visible
		 */
		isVisible : function() {
			return this._isVisible;
		},
		
<span id='LITE-LITEPlugin-method-isTracking'>		/**
</span>		 * Are changes tracked?
		 * @returns {Boolean} true if changes are tracked
		 */
		isTracking: function() {
			return this._isTracking;
		},
		
<span id='LITE-LITEPlugin-method-acceptAll'>		/**
</span>		 * Accept all tracked changes
		 * @param {LITE.AcceptRejectOptions} options for matching changes to accept
		 */
		acceptAll: function(options) {
			this._tracker.acceptAll(options);
			this._cleanup();
			this._editor.fire(LITE.Events.ACCEPT, {lite: this, options : options});
		},
		
<span id='LITE-LITEPlugin-method-rejectAll'>		/**
</span>		 * Reject all tracked changes
		 * @param {LITE.AcceptRejectOptions} options for matching changes to accept
		 */
		rejectAll: function(options) {
			this._tracker.rejectAll(options);
			this._cleanup();
			this._editor.fire(LITE.Events.REJECT, {lite: this, options : options});
		},
		
<span id='LITE-LITEPlugin-method-setUserInfo'>		/**
</span>		 * Set the name &amp; id of the current user
		 * @param {Object} info an object with the fields `name`, `id`
		 */
		setUserInfo: function(info) {
			info = info || {};
			this._config.userId = String(info.id);
			this._config.userName = info.name || &quot;&quot;;
			if (this._tracker) {
				this._tracker.setCurrentUser({ id: this._config.userId, name : this._config.userName });
			}
/*			if (this._editor) {
				var lite = this._editor.config.lite || {};
				this._editor.config.lite = lite;
			}; */
		},
		
<span id='LITE-LITEPlugin-method-getUserInfo'>		/**
</span>		 * Returns a copy of the properties of the current user: id, name
		 * @returns {Object} an object with the properties &lt;strong&gt;id&lt;/strong&gt; and &lt;strong&gt;name&lt;/strong&gt;
		 */
		getUserInfo: function() {
			return this._tracker ? this._tracker.getCurrentUser() : { name: &quot;&quot;, id: &quot;&quot;};
		},
		
<span id='LITE-LITEPlugin-method-countChanges'>		/**
</span>		 * Return the count of pending changes
		 * @param {LITE.AcceptRejectOptions} [options=null] optional filtering for the changes we want to count.
		 */
		countChanges : function(options) {
			return (this._tracker &amp;&amp; this._tracker.countChanges(options)) || 0;		
		},
		
<span id='LITE-LITEPlugin-method-enableAcceptReject'>		/**
</span>		 * Enable or disable the accept changes ui. This does not affect the availabibility of the accept/reject api
		 * @param {Boolean} bEnable
		 */
		enableAcceptReject : function(bEnable) {
			this._canAcceptReject  = Boolean(bEnable);
			this._onIceChange();
		},
		
<span id='LITE-LITEPlugin-method-filterIceElement'>		/**
</span>		 * For the CKEditor content filtering system, not operational yet
		 */
		filterIceElement : function( e ) {
			if (! e) {
				return true;
			}
			try {
				if (e.hasClass(LITEConstants.insertClass) || e.hasClass(LITEConstants.deleteClass)) {
					return false;
				}
			}
			catch (e) {
			}
			return true;
		},
		
<span id='LITE-LITEPlugin-method-startNewSession'>		/**
</span>		 * Create a new session. The change tracker unifies adjacent changes from the same user id, unless they are
		 * from different sessions
		 */
		startNewSession: function() {
			var now = new Date();
			this._sessionId = String.fromCharCode(65 + Math.round(Math.random() * 26)) + now.getDate() + now.getDay() + now.getHours() + now.getMinutes() + now.getMilliseconds();
			if (this._tracker) {
				this._tracker.setSessionId(this._sessionId);
			}
		},
		
<span id='LITE-LITEPlugin-method-getCleanMarkup'>		/**
</span>		 * returns the provided html, or the html content of the editor, without change tracking markup and without deleted changes
		 * @param {String} text optional html to clean up 
		 * @returns {String}
		 */
		getCleanMarkup: function(text) {
			if (null === text || undefined === text) {
				text = (this._editor &amp;&amp; this._editor.getData())  || &quot;&quot;;
			}
			for (var i = _cleanRE.length - 1; i &gt;= 0; --i) {
				text = text.replace(_cleanRE[i].regex, _cleanRE[i].replace);
			}
			return text;
		},
		
<span id='LITE-LITEPlugin-method-getCleanText'>		/**
</span>		 * Returns the text content of the editor, without deleted changes
		 * @returns
		 */
		getCleanText : function() {
			var doc = this._getDocument();
			if (! doc) {
				return &quot;&quot;;
			}
			var data = this._editor.getData(),
				root = doc.createElement(&quot;DIV&quot;);
			root.innerHTML = data;
			var textFragments = [];
			textFragments.push(&quot;&quot;);
			var deleteClass = this._tracker.getDeleteClass();
			this._getCleanText(root, textFragments, deleteClass);
			var str = textFragments.join(&quot;\n&quot;);
			str = str.replace(/&amp;nbsp(;)?/ig, ' ');
			return str;
		},
		
<span id='LITE-LITEPlugin-method-acceptChange'>		/**
</span>		 * Accept the change associated with a DOM node
		 * @param node either a DOM node or a CKEditor DOM node
		 */
		acceptChange: function(node) {
			node = nodeToDOMNode(node);
			if (node &amp;&amp; this._tracker) {
				this._tracker.acceptChange(node);
				this._cleanup();
				this._editor.fire(LITE.Events.ACCEPT, {lite:this});
				this._onSelectionChanged(null);
			}
		},
		
<span id='LITE-LITEPlugin-method-rejectChange'>		/**
</span>		 * Reject the change associated with a DOM node
		 * @param node either a DOM node or a CKEditor DOM node
		 */
		rejectChange: function(node) {
			node = nodeToDOMNode(node);
			if (node &amp;&amp; this._tracker) {
				this._tracker.rejectChange(node);
				this._cleanup();
				this._editor.fire(LITE.Events.REJECT, {lite:this});
				this._onSelectionChanged(null);
			}
		},
		
<span id='LITE-LITEPlugin-method-getChanges'>		/**
</span>		 * get a map of the pending changes. The keys are the change ids,
		 * the values are objects with the type, time, lastTime, session id, user id, user name, data (arbitrary string associated with the change)
		 * @param {LITE.AcceptRejectOptions} [options=null] filtering options for the returned changes
		 */
		getChanges: function(options) {
			return (this._tracker &amp;&amp; this._tracker.getChanges(options)) || {}; 
		},
		
		////////////// Implementation ///////////////

		_getCleanText : function(e, textFragments, deleteClass) { // assumed never to be called with a text node
			var cls = e.getAttribute(&quot;class&quot;);
			if (cls &amp;&amp; cls.indexOf(deleteClass) &gt;= 0) {
				return;
			}
			
			var isBlock;
			if (isBlock = ((e.nodeName &amp;&amp; e.nodeName.toUpperCase() === &quot;BR&quot;) || (&quot;block&quot; === jQuery(e).css(&quot;display&quot;)))) {
				if (_emptyRegex.test(textFragments[textFragments.length - 1])) {
					textFragments[textFragments.length - 1] = &quot;&quot;;
				}
				else {
					textFragments.push(&quot;&quot;);
				}
			}
			for (var child = e.firstChild; child; child = child.nextSibling) {
				var nodeType = child.nodeType;
				if (3 == nodeType) {
					textFragments[textFragments.length - 1] += String(child.nodeValue);
				}
				else if (1 == nodeType || 9 == nodeType || 11 == nodeType) {
					this._getCleanText(child, textFragments, deleteClass);
				}
			}
			if (isBlock) {
				textFragments.push(&quot;&quot;);
			}
		},
		
		_onDomLoaded : function(dom) {
			this._domLoaded = true;
			this._editor = dom.editor;
			var ed = this._editor.editable();
			ed.attachListener(ed, &quot;mousedown&quot;, this._onMouseDown, this, null, 1);
			ed.attachListener(ed, &quot;keypress&quot;, this._onKeyPress, this, null, 1);
//TEMP
			this._hideTooltip(); // clean up any leftover tooltip elements
			this._onReady();
		},
		
		_onScriptsLoaded : function(/*completed, failed */) {
			this._scriptsLoaded = true;
			this._onReady();
		},
		
		_loadCSS : function(doc, options) {
			var head = doc.getElementsByTagName(&quot;head&quot;)[0],
				cssPath = options.cssPath,
				pathPrefix = this.path;
			function load(path, id) {
				if (! path) {
					return;
				}
				var style = jQuery(head).find('#' + id);
				if (! style.length) {
					style = doc.createElement(&quot;link&quot;);
					style.setAttribute(&quot;rel&quot;, &quot;stylesheet&quot;);
					style.setAttribute(&quot;type&quot;, &quot;text/css&quot;);
					style.setAttribute(&quot;id&quot;, id);
					style.setAttribute(&quot;href&quot;, pathPrefix + path);
					head.appendChild(style);
				}
			}
			if (cssPath !== false) {
				load(cssPath || options.defaultCssPath, &quot;__lite__css__&quot;);
			}
			
			if (this._config.tooltips.cssPath) {
				load(this._config.tooltips.cssPath, &quot;__lite_tt_css__&quot;);
			}
		},
		
		_onReady : function() {
			if (! this._scriptsLoaded || ! this._domLoaded) {
				return;
			}
			// leave some time for initing, seems to help...
			setTimeout(this._afterReady.bind(this), 5);
		},
		
		_getBody : function() {
			try {
				return this._editor.editable().$;
			}
			catch (e) {
				return null;
			}
		},
		
		_getDocument: function() {
			return this._editor &amp;&amp; this._editor.document &amp;&amp; this._editor.document.$;		
		},
		
		_afterReady : function() {
			var e = this._editor,
				doc = e.document.$,
				body = this._getBody(),
				config = this._config,
				debug = (config &amp;&amp; config.debug) || {};
			
			this._loadCSS(doc, { cssPath: config.cssPath, defaultCssPath: &quot;css/lite.css&quot; });
			
			if (! this._eventsBounds) {
				this._eventsBounds = true;
				var paste = this._onPaste.bind(this);
				e.on(&quot;afterCommandExec&quot;, this._onAfterCommand.bind(this));
				e.on(&quot;beforeCommandExec&quot;, this._onBeforeCommand.bind(this));
				if (this._config.handlePaste) {
					e.on(&quot;paste&quot;, paste, null, null, 1);
				}
				e.on(&quot;beforeGetData&quot;, this._onBeforeGetData.bind(this));
				e.on(&quot;beoreUndoImage&quot;, this._onBeforeGetData.bind(this)); // treat before undo as before getdata
				e.on(&quot;insertHtml&quot;, paste, null, null, 1);
				e.on(&quot;insertText&quot;, paste, null, null, 1);
				e.on(&quot;insertElement&quot;, paste, null, null, 1);
				e.on(&quot;mode&quot;, this._onModeChange.bind(this), null, null, 1);
				e.on(&quot;readOnly&quot;, this._onReadOnly.bind(this));
			}
			
			if (this._tracker) {
				if (body != this._tracker.getContentElement()) {
					this._tracker.stopTracking(true);
					jQuery(this._tracker).unbind();
					this._tracker = null;
				}
			}
		
			if (this._tracker) {
				return;
			}
			var iceprops = {
				element: body,
				mergeBlocks : false,
				currentUser: {
					id: config.userId || &quot;&quot;,
					name: config.userName || &quot;&quot;
				},
				userStyles: config.userStyles,
				changeTypes: {
					insertType: {tag: LITEConstants.insertTag, alias: LITEConstants.insertClass, action:&quot;Inserted&quot;},
					deleteType: {tag: LITEConstants.deleteTag, alias: LITEConstants.deleteClass, action:&quot;Deleted&quot;}
				},
				hostMethods: {
					getHostRange : this._getHostRange.bind(this),
					getHostRangeData: this._getHostRangeData.bind(this),
					makeHostElement: function(node) {
						return new CKEDITOR.dom.element(node);
					},
					getHostNode: function(node) {
						return node &amp;&amp; node.$;
					},
					setHostRange: this._setHostRange.bind(this),
					hostCopy: this._hostCopy.bind(this),
					beforeEdit: this._beforeEdit.bind(this)/*,
					notifyChange: this._afterEdit.bind(this)*/
				}
			};
			if (debug.log) {
				iceprops.hostMethods.logError = _logError;
			}

			iceprops.tooltips = config.tooltips.show;
			if (iceprops.tooltips) {
				var hideTT = this._hideTooltip.bind(this);
				iceprops.hostMethods.showTooltip = this._showTooltip.bind(this);
				iceprops.hostMethods.hideTooltip = hideTT;
				iceprops.hostMethods.beforeDelete = iceprops.hostMethods.beforeInsert = hideTT;
				if (config.tooltips.classPath) {
					try {
						this._tooltipsHandler = new window[config.tooltips.classPath]();
						iceprops.tooltipsDelay = config.tooltips.delay;
					}
					catch (e){}
					if (! this._tooltipsHandler) {
						_logError(&quot;Unable to create tooltip handler&quot;, config.tooltips.classPath);
					}
					else {
						this._tooltipsHandler.init(config.tooltips);
					}
				}
			}
			jQuery.extend(iceprops, LITEConstants);
			this._tracker = new ice.InlineChangeEditor(iceprops);
			try {
				this._tracker.startTracking();
				this.toggleTracking(this._isTracking, false);
				this._updateTrackingState();
				jQuery(this._tracker)
					.on(&quot;change&quot;, this._onIceChange.bind(this))
					.on(&quot;textChange&quot;, this._onIceTextChanged.bind(this));
				e.fire(LITE.Events.INIT, {lite: this});
				this._onSelectionChanged(null);
				this._onIceChange(null);
			}
			catch(e) {
				_logError(&quot;ICE plugin init:&quot;, e);
			}
		},
		
		_onToggleShow : function(/*event */) {
			this.toggleShow();
		},
		
		_onToggleTracking : function(/*event */) {
			this.toggleTracking();
		},
		
		_onRejectAll : function(/*event */)  {
			this.rejectAll();
		},
		
		_onAcceptAll : function(/*event */) {
			this.acceptAll();
		},
		
		_onAcceptOne : function(/*event */) {
			var node = this._tracker.currentChangeNode();
			return this.acceptChange(node);
		},
		
		_onRejectOne : function(/*event */) {
			var node = this._tracker.currentChangeNode();
			return this.rejectChange(node);
		},
		
		_onToggleTooltips: function(/*event */) {
			this._tracker &amp;&amp; this._tracker.toggleTooltips();
		},
		
<span id='LITE-LITEPlugin-method-_cleanup'>		/**
</span>		 * Clean up empty ICE elements
		 * @private
		 */
		_cleanup : function() {
			var body = this._getBody(),
				empty = jQuery(body).find(self.insertSelector + ':empty,' + self.deleteSelector + ':empty');
			empty.remove();
			this._onSelectionChanged(null);
		},
		
<span id='LITE-LITEPlugin-method-_setButtonTitle'>		/**
</span>		 * Sets the title of a button
		 * @private
		 * @param button
		 * @param title
		 */
		_setButtonTitle : function(button, title) {
			var e = jQuery('#' + button._.id);
			e.attr('title', title);
		},
		
<span id='LITE-LITEPlugin-method-_onAfterCommand'>		/**
</span>		 * Called after the execution of a CKEDITOR command
		 * @private
		 * @param event
		 */
		_onAfterCommand: function(event) {
			var name = this._tracker &amp;&amp; this._isTracking &amp;&amp; event.data &amp;&amp; event.data.name;
			if (&quot;undo&quot; === name || &quot;redo&quot; === name) {
				this._tracker.reload();
			}
		},
		
		_onBeforeCommand: function(event) {
			var name = this._tracker &amp;&amp; this._tracker.isTracking() &amp;&amp; event.data &amp;&amp; event.data.name;
			if (&quot;cut&quot; === name) {
				if (testClipboardCommand(this._editor, &quot;copy&quot;)) {
					this._tracker.prepareToCut();
				}
			}
			else if (&quot;copy&quot; === name) {
				if (testClipboardCommand(this._editor, &quot;copy&quot;)) {
					this._tracker.prepareToCopy();
				}
			}
		},
		
<span id='LITE-LITEPlugin-method-_onModeChange'>		/**
</span>		 * Called after the mode of the editor (wysiwyg/source) changes
		 * @private
		 * @param ignore The event
		 */
		_onModeChange: function(ignore){
			this._updateTrackingState();
			setTimeout(this._onIceChange.bind(this), 0);
		},
		
		_onKeyPress: function(evt) {
			var code = evt &amp;&amp; evt.data &amp;&amp; evt.data.getKeystroke();
			if (isCutKeystroke(code)) {
				evt.stop();
			}
		},
		
		_onKeyDown: function(evt) {
			if (! this._tracker || ! this._tracker.isTracking()) {
				return;
			}
			
			var code = evt.data.keyCode;
/*
 * 				case CKEDITOR.CTRL + 86: // CTRL+V
				case CKEDITOR.SHIFT + 45: // SHIFT+INS
 */			
			if (isCutKeystroke(code)) {
				if (this._tracker.tryToCut()) {
					evt.stop();
				}
			} 
		},

		_onMouseDown: function(/*evt*/) {
			this._hideTooltip();
		},
		
<span id='LITE-LITEPlugin-method-_onBeforeGetData'>		/**
</span>		 * Callback for the editor's beforeGetData event
		 * Remove tooltips from dom
		 * @private
		 */
		_onBeforeGetData: function(/*evt*/) {
			this._hideTooltip();
		},
		
<span id='LITE-LITEPlugin-method-_onAfterSetData'>		/**
</span>		 * Callback for the editor's afterSetData event
		 * Remove tooltips from dom
		 * @private
		 */
		_onAfterSetData: function(/*evt*/) {
			this._hideTooltip();
			this._processContent();
			if (this._tracker/* &amp;&amp; this._tracker.isTracking() */) {
				this._tracker.reload();
			}
		},
		
<span id='LITE-LITEPlugin-method-_onReadOnly'>		/**
</span>		 * Called after the readonly state of the editor changes
		 * @private
		 */
		_onReadOnly: function(/*evt*/){
			this._updateTrackingState();			
		},
		
<span id='LITE-LITEPlugin-method-_updateTrackingState'>		/**
</span>		 * Recalculates the tracking state according to the tracking flag, editor mode and editor readonly
		 * @private
		 */
		_updateTrackingState: function() {
			if (this._tracker) {
				var track = this._isTracking &amp;&amp; this._editor.mode === &quot;wysiwyg&quot; &amp;&amp; ! this._editor.readOnly;
				if (track === this._trackingState) {
					return;
				}
				this._trackingState = track;
				this._tracker.toggleChangeTracking(track);
				for (var i = this._removeBindings.length - 1; i &gt;= 0; --i) {
					this._removeBindings[i].removeListener();
				}
				this._removeBindings = [];
				this._tracker.unlistenToEvents();
				if (track) {
					var handler = this._onSelectionChanged.bind(this),
						editable = this._editor.editable();
					if (isOldCKEDITOR) {
						this._tracker.listenToEvents();
					}
					else {
						this._removeBindings.push(this._editor.on(&quot;key&quot;, function(e) {
							if (this._tracker) {
								var event = e.data.domEvent &amp;&amp; e.data.domEvent.$;
								// onkeydown returns true to prevent, so return false it it returns true
								return event ? this._tracker.handleEvent(event) : true;
							}
							return true;
						}.bind(this)));
					}
					this._removeBindings.push(editable.on(&quot;keyup&quot;, this._onSelectionChanged.bind(this, null, false)));
					this._removeBindings.push(editable.on(&quot;click&quot;, handler));
					this._removeBindings.push(this._editor.on(&quot;selectionChange&quot;, handler));					
				}
			}
		},

<span id='LITE-LITEPlugin-method-_onPaste'>		/**
</span>		 * Paste the content of the clipboard through ICE
		 * @private
		 */
		_onPaste : function(evt){
			/* Test data
			 * &quot;&lt;ins&gt;&lt;div&gt;man&lt;/div&gt;&lt;p&gt;&lt;del&gt;&lt;div&gt;&lt;ins&gt;who is this guy&lt;/ins&gt;&lt;del&gt;this is deleted&lt;/del&gt;&lt;/div&gt;&lt;div&gt;&lt;del&gt;&lt;span&gt;text1&lt;/span&gt;&lt;ins&gt;&lt;div&gt;calling all nature&lt;/div&gt;&lt;del&gt;inner del&lt;/del&gt;&lt;/ins&gt;&lt;/del&gt;&lt;/div&gt;&lt;span&gt;going again&lt;/span&gt;&lt;h2&gt;the thing&lt;/h2&gt;&lt;/del&gt;&lt;/p&gt;&lt;/ins&gt;&quot;
			 */
			if (! this._tracker || ! this._isTracking || ! evt) {
				return true;
			}
			var data = evt.data || {},
				toInsert = null,
				selectors = [&quot;[data-track-changes-ignore]&quot;].concat(this._config.ignoreSelectors || []),
				$ = window.jQuery,
				node = (evt.name == &quot;insertElement&quot;) &amp;&amp; data.$;
			if (! data) {
				return;
			}
			if (&quot;string&quot; === typeof data) {
				data = {
					dataValue: data,
					type: &quot;text&quot;
				};
			}
			if (data.dataValue &amp;&amp; (&quot;html&quot; === (data.type || data.mode))) {
				try {
					node = jQuery(data.dataValue);
				}
				catch (e) {}
			}
			
			if (&quot;string&quot; === typeof data.dataValue) {
				try {
					var doc = this._editor.document.$,
						container = doc.createElement(&quot;div&quot;);
					container.innerHTML = String(data.dataValue);
					container = this._tracker.getCleanDOM(container);
					if (! container.innerHTML) {
						return true;
					}
					toInsert = jQuery.makeArray(container.childNodes);
				}
				catch (e) {
					_logError(&quot;ice plugin paste:&quot;, e);
				}
			}
			else if (node) {
				toInsert = [node];
			}
			else {
				return true;
			}
			if (toInsert &amp;&amp; selectors.length) {
				toInsert = toInsert.filter(function(e) {
					return ! elementMatchesSelectors($(e), selectors);
				});
			}
			if (toInsert &amp;&amp; toInsert.length) {
				toInsert = cleanClipboard(toInsert);
				var focused = this._editor.focusManager.hasFocus;
				this._beforeInsert();
				this._tracker.insert({nodes: toInsert});
				this._afterInsert();
				if (focused) {
					this._editor.editable().focus();
				}
				evt.stop();
//				this._onIceTextChanged();
			}

			return true;
		},
		
<span id='LITE-LITEPlugin-method-_setCommandsState'>		/**
</span>		 * Set the state of multiple commands
		 * @param commands An array of command names or a comma separated string
		 * @param state CKEDITOR command state
		 * @private
		 */
		_setCommandsState: function(commands, state) {
			if (typeof(commands) === &quot;string&quot;) {
				commands = commands.split(&quot;,&quot;);
			}
			for (var i = commands.length - 1; i &gt;= 0; --i) {
				var cmd = this._editor.getCommand(commands[i]);
				if (cmd) {
					cmd.setState(state);
				}
			}
		},
		
<span id='LITE-LITEPlugin-method-_onSelectionChanged'>		/**
</span>		 * Handler for selection change events (caret moved or text marked/unmarked)
		 * @param event
		 * @param cleanupDOM flag passed to the tracker's isInsideChange method. Must be false to avoid cleaning up dom
		 * @private
		 */
		_onSelectionChanged : function(event, cleanupDOM) {
			var inChange = this._isTracking &amp;&amp; this._tracker &amp;&amp; this._tracker.isInsideChange(null, null, cleanupDOM),
				state = inChange &amp;&amp; this._canAcceptReject ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED;
			this._setCommandsState([LITE.Commands.ACCEPT_ONE, LITE.Commands.REJECT_ONE], state);
		},
		
<span id='LITE-LITEPlugin-method-_onIceChange'>		/**
</span>		 * called when ice fires a change event
		 * @param e jquery event
		 * @private
		 */
		_onIceChange : function(e) {
			var hasChanges = this._isTracking &amp;&amp; this._tracker &amp;&amp; this._tracker.hasChanges();
			var state = hasChanges &amp;&amp; this._canAcceptReject ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED;
			this._setCommandsState([LITE.Commands.ACCEPT_ALL, LITE.Commands.REJECT_ALL], state);
			this._onSelectionChanged();
			if (e) { //otherwise it's just a ui update
				this._triggerChange();
			}
		},
		
<span id='global-method-_onIceTextChanged'>		/**
</span>		 * @ignore
		 * @param ignore event
		 */
		_onIceTextChanged : function(ignore) {
			this._editor.fire(&quot;change&quot;);
			this._editor.fire('saveSnapshot');
		},
		
<span id='global-method-_triggerChange'>		/**
</span>		 * @ignore
		 */
		_triggerChange : function() {
			if (! this._changeTimeout) {
				this._changeTimeout = setTimeout(this._notifyChange, 1);
			}
		},
		
<span id='global-method-_notifyChange'>		/**
</span>		 * @ignore
		 */
		_notifyChange : function() {
			this._changeTimeout = null;
			this._editor.fire(LITE.Events.CHANGE, {lite:this});
		},

<span id='global-method-_notifyTextChange'>		/**
</span>		 * @ignore
		 */
		_notifyTextChange : function() {
			this._changeTimeout = null;
			this._editor.fire('change',{lite:this});
		},
		
<span id='global-method-_processContent'>		/**
</span>		 * @ignore
		 */
		_processContent: function() {
			var body = this._getBody(),
				$ = window.jQuery,
				insTag = LITEConstants.insertTag,
				delTag = LITEConstants.deleteTag,
				nodes, doc;
			if (! body) {
				return;
			}
			doc = body.ownerDocument;
			function replaceNode(node, tag) {
				var parent = node.parentNode,
					newNode = doc.createElement(tag);
				$.each( node.attributes, function( index, attr ) {
	                newNode.setAttribute(attr.name, attr.value);
	            });
				newNode.className = node.className || &quot;&quot;;
				$(node).contents().appendTo(newNode);
				parent.insertBefore(newNode, node);
				parent.removeChild(node);
			}
			
			if (insTag !== &quot;span&quot;) {
				nodes = $(body).find(&quot;span.&quot; + LITEConstants.insertClass);
				nodes.each(function(i, node) {
					replaceNode(node, insTag);
				});
			}
			if (delTag !== &quot;span&quot;) {
				nodes = $(body).find(&quot;span.&quot; + LITEConstants.deleteClass);
				nodes.each(function(i, node) {
					replaceNode(node, delTag);
				});
			}
		},
		
<span id='global-method-_commandNameToUIName'>		/**
</span>		 * @ignore
		 * @param command
		 * @returns
		 */
		_commandNameToUIName : function(command) {
			return command.replace(&quot;.&quot;, &quot;_&quot;);
		},
		
<span id='global-method-_setPluginFeatures'>		/**
</span>		 * @ignore
		 * @param editor
		 * @param props
		 */
		_setPluginFeatures : function(editor, props) {
			function makeClasses() {
				return [props.deleteClass,props.insertClass,props.stylePrefix+'*'];
			}
			
			function makeAttributes() {
				var attrs = ['title'];
				for (var key in props.attributes) {
					if (props.attributes.hasOwnProperty(key)) {
						var value = props.attributes[key];
						if ((typeof value === &quot;string&quot;) &amp;&amp; value.indexOf(&quot;data-&quot;) === 0) {
							attrs.push(value);
						}
					}
				}
				return attrs;
			}
			
			function makeFeature(arr) {
				var ret = {};
				arr.forEach(function(member) {
					ret[member] = true;
				});
				return ret;
			}

			if (! editor || ! editor.filter || ! editor.filter.addFeature) {
				return;
			}
			
			try {	
				var features = [], feature, fields;
				
				feature = {};
				fields = {};
				fields.classes = makeFeature(makeClasses());
				fields.attributes = makeFeature(makeAttributes());
				feature[props.insertTag] = fields;
				feature[props.deleteTag] = CKEDITOR.tools.clone(fields);

				feature['br'] = CKEDITOR.tools.clone(fields);
				feature['br'].propertiesOnly = true;

				// prepare to clean up legacy data
				feature.span = CKEDITOR.tools.clone(fields);

				editor.filter.addFeature({
					name: &quot;lite-features&quot;,
					allowedContent: feature
				});				
			}
			catch (e){
				_logError(e);
			}
		},
		
<span id='global-method-_setHostRange'>		/**
</span>		 * @ignore
		 * @param range
		 */
		_setHostRange: function(range) {
			var selection = this._editor &amp;&amp; this._editor.getSelection();
			if (selection) {
				selection.selectRanges([range]);
			}
		},
		
/*		_afterEdit: function() {
			this._editor.fire('change');
			this._editor.fire('saveSnapshot');
		},
*/		
		_beforeEdit: function() {
			CKEDITOR.iscutting = true;
			var e = this._editor,
				f = function() {
					e.fire('saveSnapshot');
				};
			f();// Save before cut
			setTimeout(function() {
				CKEDITOR.iscutting = false;
			}, 100);
//			setTimeout(f, 30);
		},
		
		_hostCopy: function() {
			try {
				if ( CKEDITOR.env.ie ) {
					testIECommand(this._editor, &quot;copy&quot; ); 
				}
				else {
					// Other browsers throw an error if the command is disabled.
					this._editor.document.$.execCommand( &quot;copy&quot;, false, null );
				} 
			}
			catch ( e ) {
				_logError(e);
			}
		},

<span id='global-method-_getHostRange'>		/**
</span>		 * @ignore
		 * @returns {Boolean}
		 */
		_getHostRange: function() {
			var selection = this._editor &amp;&amp; this._editor.getSelection(),
				ranges = selection &amp;&amp; selection.getRanges(),
				range = ranges &amp;&amp; ranges[0];
			return range || null;
		},
		
		_getHostRangeData: function(hostRange) {
			hostRange = hostRange || this._getHostRange();
			if (! hostRange) {
				return null;
			}
			return {
				startContainer: hostRange.startContainer &amp;&amp; hostRange.startContainer.$,
				endContainer: hostRange.endContainer &amp;&amp; hostRange.endContainer.$,
				startOffset: hostRange.startOffset,
				endOffset: hostRange.endOffset
			};
		},
		
<span id='global-method-_showTooltip'>		/**
</span>		 * @ignore
		 * @param node
		 * @param change
		 */
		_showTooltip: function(node, change) {
			var config = this._config.tooltips;
			if (config.events) {
				return this._editor &amp;&amp; this._editor.fire(LITE.Events.HOVER_IN, {
					lite:this,
					node: node,
					changeId: change.changeId});
			}
			if (config.show) {
				var title = this._makeTooltipTitle(change);
				if (this._tooltipsHandler) {
					this._tooltipsHandler.hideAll(this._getBody());
					this._tooltipsHandler.showTooltip(node, title, this._editor.container.$);
				}
				else {
					node.setAttribute(&quot;title&quot;, title);
				}
			}
		},
		
<span id='global-method-_hideTooltip'>		/**
</span>		 * @ignore
		 * @param node
		 */
		_hideTooltip: function(node) {
			var config = this._config.tooltips;
			if (config.events) {
				return this._editor &amp;&amp; this._editor.fire(LITE.Events.HOVER_OUT, {
					lite:this,
					node: node
				});
			}
			if (this._tooltipsHandler) {
				if (node) {
					this._tooltipsHandler.hideTooltip(node);
				}
				else {
					this._tooltipsHandler.hideAll(this._getBody());
				}
			}
			else {
				if (this._tracker) {
					if (node) {
						node.removeAttribute(&quot;title&quot;);
					}
					else {
						var nodes = this._tracker.getIceNodes();
						if (nodes) {
							nodes.removeAttr(&quot;title&quot;);
						}
					}
				}
			}
		},
		
<span id='global-method-_beforeInsert'>		/**
</span>		 * Copied from ckeditor
		 * @ignore
		 */
		_beforeInsert: function() {
			this._editor.fire( 'saveSnapshot' );
		},

<span id='global-method-_afterInsert'>		/**
</span>		 * Copied from ckeditor
		 * @ignore
		 */
		_afterInsert: function( ) {
			var editor = this._editor;

			editor.getSelection().scrollIntoView();
/*			setTimeout( function() {
				editor.fire( 'saveSnapshot' );
			}, 0 ); */
		},
		
<span id='global-method-_makeTooltipTitle'>/**
</span> * @ignore
 * @param change
 * @returns {Boolean}
 */		_makeTooltipTitle: function(change) {
			var title = this._config.tooltipTemplate || defaultTooltipTemplate,
				time = new Date(change.time),
				lastTime = new Date(change.lastTime),
				lang = this._editor.lang.lite;
			title = title.replace(/%a/g, &quot;insert&quot; === change.type ? lang.CHANGE_TYPE_ADDED : lang.CHANGE_TYPE_DELETED);
			title = title.replace(/%t/g, relativeDateFormat(time, lang));
			title = title.replace(/%u/g, change.userName);
			title = title.replace(/%dd/g, padNumber(time.getDate(), 2));
			title = title.replace(/%d/g, time.getDate());
			title = title.replace(/%mm/g, padNumber(time.getMonth() + 1, 2));
			title = title.replace(/%m/g, time.getMonth() + 1);
			title = title.replace(/%yy/g, padNumber(time.getYear() - 100, 2));
			title = title.replace(/%y/g, time.getFullYear());
			title = title.replace(/%nn/g, padNumber(time.getMinutes(), 2));
			title = title.replace(/%n/g, time.getMinutes());
			title = title.replace(/%hh/g, padNumber(time.getHours(), 2));
			title = title.replace(/%h/g, time.getHours());

			title = title.replace(/%T/g, relativeDateFormat(lastTime, lang));
			title = title.replace(/%DD/g, padNumber(lastTime.getDate(), 2));
			title = title.replace(/%D/g, lastTime.getDate());
			title = title.replace(/%MM/g, padNumber(lastTime.getMonth() + 1, 2));
			title = title.replace(/%M/g, lastTime.getMonth() + 1);
			title = title.replace(/%YY/g, padNumber(lastTime.getYear() - 100, 2));
			title = title.replace(/%Y/g, lastTime.getFullYear());
			title = title.replace(/%NN/g, padNumber(lastTime.getMinutes(), 2));
			title = title.replace(/%N/g, lastTime.getMinutes());
			title = title.replace(/%HH/g, padNumber(lastTime.getHours(), 2));
			title = title.replace(/%H/g, lastTime.getHours());

			return title;
		}
		

		
	};
	
<span id='global-method-_logError'>	/**
</span>	 * @ignore
	 */
	function _logError() {
		var console = window.console;
		if (console &amp;&amp; console.error) {
			console.error.apply(console, [].slice.call(arguments));
		}
	}
	
	function testClipboardCommand(editor, command) {
		if ( CKEDITOR.env.ie ) {
			return testIECommand(editor, command);
		}

		// non-IEs part
		try {
			// Other browsers throw an error if the command is disabled.
			return editor.document.$.execCommand( command, false, null );
		} 
		catch ( e ) {
			return false;
		}
	}

<span id='LITE-LITEPlugin-method-testIECommand'>	/**
</span>	 * Tries to execute any of the paste, cut or copy commands in IE. Returns a
	 * boolean indicating that the operation succeeded.
	 * Copied from ckeditor
	 * @param editor instance of CKEditor
	 * @param {String} command *LOWER CASED* name of command ('paste', 'cut', 'copy').
	 * */
	function testIECommand( editor, command ) {
		var doc = editor.document,
			body = doc.getBody(),
			enabled = false,
			success,
			onExec = function() {
				enabled = true;
			};

		// The following seems to be the only reliable way to detect that
		// clipboard commands are enabled in IE. It will fire the
		// onpaste/oncut/oncopy events only if the security settings allowed
		// the command to execute.
		body.on( command, onExec );

		// IE7: document.execCommand has problem to paste into positioned element.
		success = ( CKEDITOR.env.version &gt; 7 ? doc.$ : doc.$.selection.createRange() )[ 'execCommand' ]( command, false );

		body.removeListener( command, onExec );

		return success || enabled;
	}

})(window.CKEDITOR, this || window);
</pre>
</body>
</html>
